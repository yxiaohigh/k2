<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HID Passthrough Tool</title>
  <style>
    .container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .showshow {
      margin-top: 20px;
      width: 220px;
      height: 253px;
    }
  </style>
  <script>
    if ("hid" in navigator) {
      // 浏览器支持hid
    } else {
      alert("Your browser is not support Web HID API.");
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
</head>

<body>
  <div class="container">
    <button id="btnOpen">open</button>
    <textarea id="spanInput" class="showshow" readonly></textarea>
    <div id="main" style="width: 90%; height: 600px;"></div>
    <div>
      <label for="barType">选择统计类型:</label>
      <select id="barType">
        <option value="power">功率</option>
        <option value="current">电流</option>
        <option value="voltage">电压</option>
      </select>
    </div>
    <div id="powerBarChart" style="width: 50%; height: 400px; margin-top: 30px;"></div>
  </div>
  <script>
    const btnOpen = document.querySelector("#btnOpen");

    let device; // 需要连接或已连接的设备
    let inputDataLength; // 发送数据包长度
    let outputDataLength; // 发送数据包长度

    let chartDom = document.getElementById('main');
    let myChart = echarts.init(chartDom);

    let powerBarChartDom = document.getElementById('powerBarChart');
    let powerBarChart = echarts.init(powerBarChartDom);

    // 功率分布统计桶
    let powerBuckets = {}; // { 区间: 累计秒数 }
    let bucketSize = 1; // 功率分组区间大小（可调整）

    function getPowerBucket(power) {
      // 例如功率区间为 0~1, 1~2, 2~3 ...
      return `${Math.floor(power / bucketSize) * bucketSize}~${(Math.floor(power / bucketSize) + 1) * bucketSize}`;
    }

    // 电流分布统计桶
    let currentBuckets = {};
    let currentBucketSize = 1;
    function getCurrentBucket(current) {
      return `${Math.floor(current / currentBucketSize) * currentBucketSize}~${(Math.floor(current / currentBucketSize) + 1) * currentBucketSize}`;
    }

    // 电压分布统计桶
    let voltageBuckets = {};
    let voltageBucketSize = 1;
    function getVoltageBucket(voltage) {
      return `${Math.floor(voltage / voltageBucketSize) * voltageBucketSize}~${(Math.floor(voltage / voltageBucketSize) + 1) * voltageBucketSize}`;
    }

    const barTypeSelect = document.getElementById('barType');

    function updatePowerBarChart() {
      let type = barTypeSelect.value;
      let keys, times, title, color;
      if (type === 'power') {
        keys = Object.keys(powerBuckets).sort((a, b) => parseFloat(a.split('~')[0]) - parseFloat(b.split('~')[0]));
        times = keys.map(k => powerBuckets[k]);
        title = '功率分布统计（累计时间）';
        color = '#5470C6';
      } else if (type === 'current') {
        keys = Object.keys(currentBuckets).sort((a, b) => parseFloat(a.split('~')[0]) - parseFloat(b.split('~')[0]));
        times = keys.map(k => currentBuckets[k]);
        title = '电流分布统计（累计时间）';
        color = '#91CC75';
      } else {
        keys = Object.keys(voltageBuckets).sort((a, b) => parseFloat(a.split('~')[0]) - parseFloat(b.split('~')[0]));
        times = keys.map(k => voltageBuckets[k]);
        title = '电压分布统计（累计时间）';
        color = '#FAC858';
      }

      powerBarChart.setOption({
        title: { text: title },
        tooltip: { trigger: 'axis' },
        xAxis: {
          type: 'category',
          data: keys,
          name: '区间',
          axisLabel: { rotate: 45 }
        },
        yAxis: {
          type: 'value',
          name: '累计时间（秒）'
        },
        series: [{
          name: title,
          type: 'bar',
          data: times,
          barWidth: 20,
          itemStyle: { color }
        }]
      });
    }

    // 切换统计类型时刷新柱状图
    barTypeSelect.onchange = updatePowerBarChart;

    let times = []; // x轴时间
    let voltages = []; // 电压
    let currents = []; // 电流
    let powers = []; // 功率

    let startTime = null;

    let chartOption = {
      title: {
        text: '电压/电流/功率 实时曲线'
      },
      tooltip: {
        trigger: 'axis'
      },
      legend: {
        data: ['电压', '电流', '功率']
      },
      xAxis: {
        type: 'category',
        data: times,
        name: '时间',
        axisLabel: {
          interval: (index) => index % Math.ceil(data.length / 10) === 0,
          formatter: function (value) {
            if (typeof value === 'number' || /^\d+$/.test(value)) {
              const sec = Number(value);
              const h = Math.floor(sec / 3600);
              const m = Math.floor((sec % 3600) / 60);
              const s = sec % 60;
              return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
            return value;
          }
        }
      },
      yAxis: {
        type: 'value',
        name: '数值'
      },
      series: [
        {
          name: '电压',
          type: 'line',
          data: voltages,
          showSymbol: false // 不显示折线上的点
        },
        {
          name: '电流',
          type: 'line',
          data: currents,
          showSymbol: false
        },
        {
          name: '功率',
          type: 'line',
          data: powers,
          showSymbol: false
        }
      ]
    };

    myChart.setOption(chartOption);

    // 打开设备相关操作
    btnOpen.onclick = async () => {
      try {
        const devices = await navigator.hid.requestDevice({ filters: [] });
        if (devices.length == 0) {
          return;
        }
        device = devices[0];
        if (!device.opened) {
          await device.open();
          if (device.collections[0].inputReports[0].items[0].isArray && device.collections[0].inputReports[0].items[0].reportSize === 8) {
            inputDataLength = device.collections[0].inputReports[0].items[0].reportCount ?? 0;
          }
          if (device.collections[0].outputReports[0].items[0].isArray && device.collections[0].outputReports[0].items[0].reportSize === 8) {
            outputDataLength = device.collections[0].outputReports[0].items[0].reportCount ?? 0;
          }
        }

        var condition = 0;
        startTime = Date.now();
        device.oninputreport = (event) => {
          condition++;
          if (condition < 10) {
            return;
          }
          condition = 0;

          let array = new Uint8Array(event.data.buffer);
          let hexstr = "";
          for (const data of array) {
            hexstr += (Array(2).join(0) + data.toString(16).toUpperCase()).slice(-2) + " ";
          }

          var xx = parsePowerMeterHID(hexstr);
          spanInput.value = `
          电压: ${xx.voltage} 
          电流: ${xx.current} 
          功率: ${xx.powerConsistency}
          ===================
          D+电压: ${xx.dVoltage1} 
          D-电压: ${xx.dVoltage2} 
          =====================
          积累数据组: ${xx.type === 0 ? '1' : '2'}
          Ah积累: ${xx.Ah} 
          Wh积累: ${xx.Wh} 
          时间: ${xx.time} 
          `;

          // 采集数据，每秒一次
          let now = Date.now();
          let elapsed = Math.round((now - startTime) / 1000);
          if (times.length === 0 || elapsed > times.length - 1) {
            times.push(elapsed);
            voltages.push(Number(xx.voltage));
            currents.push(Number(xx.current));
            powers.push(Number(xx.powerConsistency));
            // 更新折线图
            myChart.setOption({
              xAxis: { data: times, axisLabel: { interval: 4 } },
              series: [
                { data: voltages, showSymbol: false },
                { data: currents, showSymbol: false },
                { data: powers, showSymbol: false }
              ]
            });

            // 功率分布统计
            const powerBucket = getPowerBucket(Number(xx.powerConsistency));
            if (!powerBuckets[powerBucket]) powerBuckets[powerBucket] = 0;
            powerBuckets[powerBucket] += 1;

            // 电流分布统计
            const currentBucket = getCurrentBucket(Number(xx.current));
            if (!currentBuckets[currentBucket]) currentBuckets[currentBucket] = 0;
            currentBuckets[currentBucket] += 1;

            // 电压分布统计
            const voltageBucket = getVoltageBucket(Number(xx.voltage));
            if (!voltageBuckets[voltageBucket]) voltageBuckets[voltageBucket] = 0;
            voltageBuckets[voltageBucket] += 1;

            updatePowerBarChart();
          }
        };
      } catch (error) {
        console.log(error);
      }
    };


    function parsePowerMeterHID(hexString) {
      // 移除所有非十六进制字符（包括行首地址）
      const cleanHex = hexString.replace(/[^0-9a-fA-F]/g, '');

      // 验证长度
      if (cleanHex.length !== 128) { // 64字节 * 2个字符/字节
        throw new Error(`无效的报文长度: ${cleanHex.length} 字符，应为128字符`);
      }

      // 将十六进制字符串转换为字节数组
      const bytes = [];
      for (let i = 0; i < cleanHex.length; i += 2) {
        bytes.push(parseInt(cleanHex.substr(i, 2), 16));
      }

      // 辅助函数：提取小端序浮点数
      const parseFloatLE = (offset) => {
        const buffer = new ArrayBuffer(4);
        const view = new DataView(buffer);
        for (let i = 0; i < 4; i++) {
          view.setUint8(i, bytes[offset + i]);
        }
        return view.getFloat32(0, true);
      };

      // 辅助函数：提取小端序16位整数
      const parseUInt16LE = (offset) => {
        return (bytes[offset + 1] << 8) | bytes[offset];
      };

      // 辅助函数：提取大端序16位整数
      const parseUInt16BE = (offset) => {
        return (bytes[offset] << 8) | bytes[offset + 1];
      };

      // 辅助函数：秒转时分秒字符串
      function formatHMS(seconds) {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = seconds % 60;
        return [
          h > 0 ? String(h).padStart(2, '0') : '00',
          String(m).padStart(2, '0'),
          String(s).padStart(2, '0')
        ].join(':');
      }

      const secondsToHMS = (seconds) => {
        // 确保输入是数字
        const totalSeconds = Number(seconds);

        // 计算小时、分钟、剩余秒
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const secs = Math.floor(totalSeconds % 60);

        const parts = [];
        if (hours) parts.push(`${hours}小时`);
        if (minutes) parts.push(`${minutes}分钟`);
        if (secs || parts.length === 0) parts.push(`${secs}秒`);

        return parts.join('');

      }



      // 解析关键字段
      const result = {
        // 帧头标识
        // header: `0x${bytes[0].toString(16).padStart(2, '0')}${bytes[1].toString(16).padStart(2, '0')}`,

        // D+电压 (30-33字节) 
        dVoltage1: parseFloatLE(30).toFixed(5),

        // D-电压 (34-37字节)  
        dVoltage2: parseFloatLE(34).toFixed(5),

        // Ah积累(14-17字节)  
        Ah: parseFloatLE(14).toFixed(5),

        // Wh积累(18-21字节)  
        Wh: parseFloatLE(18).toFixed(5),

        // 电压 (46-49字节)   
        voltage: parseFloatLE(46).toFixed(5),

        // 瞬时电流 (50-53字节小端浮点)  
        current: parseFloatLE(50).toFixed(5),
        // 累积时间 (22-23字节小端浮点)  
        time: secondsToHMS(parseUInt16LE(22)),

        type: bytes[54], // 设备类型
        //  type: bytes[54] === 0 ? '1' : '2', // 设备类型

        // 原始十六进制字符串
        // rawHex: cleanHex
      };


      const voltage = parseFloatLE(46);
      const current = parseFloatLE(50);
      const calcPower = (voltage * Math.abs(current)).toFixed(5);
      result.powerConsistency = calcPower

      return result;
    }

  </script>
</body>

</html>